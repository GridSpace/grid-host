#!/usr/bin/env node

function log(o) {
    if (typeof(o) === 'object') {
        console.log(JSON.stringify(o));
    } else {
        console.log(o);
    }
}

function lastmod(path) {
    try {
        return fs.statSync(path).mtime.getTime();
    } catch (e) {
        return 0;
    }
}

function mkdirs(path) {
    var root = "";
    path.forEach(seg => {
        if (root) {
            root = root + "/" + seg;
        } else {
            root = seg;
        }
        lastmod(root) || fs.mkdirSync(root);
    });
}

function encode(obj) {
    return JSON.stringify(obj);
}

function decode(str) {
    return JSON.parse(str);
}

function setCORSHeaders(req,res) {
    res.setHeader("Access-Control-Allow-Origin", req.headers['origin'] || '*');
    res.setHeader("Access-Control-Allow-Credentials", true);
    res.setHeader("Access-Control-Allow-Headers", "X-Moto-Ajax");
}

function init(req, res, next) {
    var parsed = url.parse(req.url, true);
    req.gs = {
        path: parsed.pathname,
        query: parsed.query,
    };
    if (req.method === 'OPTIONS') {
        setCORSHeaders(req,res);
        res.setHeader("Allow", "GET,POST,OPTIONS");
        res.end();
    } else {
        next();
    }
}

function api(req, res, next) {
    if (!req.gs.path.startsWith(apiroot)) return next();

    var queueData;

    switch (req.gs.path.substring(apiroot.length)) {
        case "targets":
            setCORSHeaders(req,res);
            res.end(encode(setup.targets));
            break;
        case "check":
            queueData = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            res.end(encode(
                queueData ? {
                    key: queueData.key,
                    pct: queueData.progress,
                    status: queueData.status,
                    error: queueData.error || false,
                    done: queueData.done
                } : {
                    error: "invalid key"
                }
            ));
            break;
        case "wait":
            queueData = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            if (queueData) {
                log({add_wait:queueData.key});
                queueData.waiting.push(res);
            } else {
                res.end(encode({error:"invalid key"}));
            }
            break;
        case "image":
            if (req.method !== 'POST') return next();
            let name = req.gs.query.filename;
            var image = '';
            req.on('data', data => { image += data });
            req.on('end', () => {
                image = Buffer.from(image, "base64");
                var png = new PNG();
                png.parse(image, (err, data) => { images[name] = png });
                setCORSHeaders(req,res);
                res.end();
            });
            break;
        case "print":
            let query = req.gs.query;

            if (req.method !== 'POST') return next();
            if (!query.filename) return next();
            if (!query.target) return next();

            var body = '',
                queueKey = new Date().getTime().toString(36);

            req.on('data', data => { body += data });
            req.on('end', () => {
                try {
                    queued[queueKey] = queueData = {
                        key: queueKey,
                        data: body,
                        image: images[query.image],
                        error: false,
                        status: "queueing",
                        target: query.target,
                        filename: query.filename || "gprint",
                        ptime: query.time || 0,
                        plength: query.length || 0,
                        waiting: []
                    };
                    log({key:queueKey, size:body.length, file:queueData.filename, target:req.gs.query.target});
                    setCORSHeaders(req,res);
                    res.end(encode({key:queueKey}));
                    printTarget(queueData);
                } catch (e) {
                    console.log(e);
                    log(e);
                    res.writeHead(500);
                    res.end(encode({error:e.toString()}));
                }
            });

            break;
        default:
            next();
    }

}

function addTarget(host, name, filter) {
    setup.targets[name || host] = {
        host: host,
        filter: filter
    };
}

function tempFileName() {
    return tempDir + "/" + (new Date().getTime().toString(36)) + "-" + (tempIndex++) + ".tmp";
}

function postFile(host, queueData) {
    log({key:queueData.key, postTo:host});
    queueData.status = "posting";
    var form = new FormData(), req;
    form.append("file", queueData.data, queueData.filename);
    form.append("submit", "submit");
    var track = progress();
    req = form.submit("http://"+host+"/upload.cgi", function(err, res) {
        if (res) res.resume();
        if (err) {
            log({key:queueData.key, err:err});
            queueData.error = true;
            queueData.status = err.toString();
        } else {
            log(encode({key:queueData.key, done:true}));
            queueData.status = "complete";
        }
        queueData.data = null;
        queueData.done = true;
        setTimeout(function() {
            delete queued[queueData.key];
        }, 600000);
        finish(queueData);
    }, track);
    track.on('progress', function(progress) {
        queueData.progress = progress.percentage;
        // log(progress);
    });
}

function finish(queueData) {
    queueData.waiting.forEach(function(res) {
        res.end(encode({
            key: queueData.key,
            done: queueData.done,
            error: queueData.error,
            status: queueData.status
        }));
    });
}

function printTarget(queueData) {
    var pt = setup.targets[queueData.target],
        filter, proc, args;

    if (!pt) throw "invalid target: "+queueData.target;
    if (pt.filter && (filter = setup.filters[pt.filter])) {
        var ext = filter.ext || '.gcode';
        var fin = tempFileName();
        var fout = tempFileName();
        var fname = filter.filename || queueData.filename;
        if (fname.indexOf(ext) < 0) {
            fname = fname + ext;
        }
        if (pt.filter == 'gx' && queueData.image) {
            console.log({image_convert: image});
            var bmp = BMP.encode({data:png.data, width:png.width, height: png.height});
            console.log({bmp:bmp});
            throw "break";
            // for (var y = 0; y < png.height; y++) {
            //     for (var x = 0; x < png.width; x++) {
            //         var idx = (png.width * y + x) << 2;
            //         // invert color
            //         this.data[idx] = 255 - this.data[idx];
            //         this.data[idx+1] = 255 - this.data[idx+1];
            //         this.data[idx+2] = 255 - this.data[idx+2];
            //         // and reduce opacity
            //         this.data[idx+3] = this.data[idx+3] >> 1;
            //     }
            // }
        }
        fname = fname.replace("{seq}", printSequence++);
        fname = fname.replace("{name}", queueData.filename);
        fs.writeFileSync(fin, queueData.data);
        args = filter.args.slice();
        args.forEach((val,idx) => {
            val = val.replace("{host}", pt.host);
            val = val.replace("{port}", pt.port);
            val = val.replace("{file-in}", fin);
            val = val.replace("{file-out}", fout);
            val = val.replace("{time}", queueData.ptime);
            val = val.replace("{length}", queueData.plength);
            val = val.replace("{filename}", queueData.filename);
            args[idx] = val;
        });
        proc = spawn(filter.path, args);
        proc.on('error', error => {
            log(error);
            queueData.done = true;
            queueData.error = true;
            queueData.status = error.toString();
            finish(queueData);
        });
        proc.on('exit', () => {
            if (!lastmod(fout)) {
                log("missing filtered output for "+filename);
                queueData.done = true;
                queueData.error = true;
                queueData.status = "missing filter output";
                return;
            }
            try {
                queueData.filename = fname;
                queueData.data = fs.readFileSync(fout);
                if (filter.post) {
                    postFile(pt.host, queueData);
                } else {
                    queueData.done = true;
                    queueData.error = false;
                    queueData.status = "spooled";
                    finish(queueData);
                }
            } catch (e) {
                queueData.done = true;
                queueData.error = true;
                queueData.status = e.toString();
            }
            fs.unlinkSync(fin);
            fs.unlinkSync(fout);
        });
        proc.stdout.on('data', data => log({
            out: data.toString()
        }));
        proc.stderr.on('data', err => log({
            err: err.toString()
        }));
    } else {
        postFile(pt.host, queueData);
    }
}

/* *********************************************
 * Start it up
 ********************************************* */

var fs = require('fs'),
    url = require('url'),
    http = require('http'),
    https = require('https')
    serve = require('serve-static')
    connect = require('connect'),
    spawn = require('child_process').spawn,
    progress = require('progress-stream'),
    FormData = require('form-data'),
    PNG = require('pngjs').PNG,
    BMP = require('bmp-js'),
    printSequence = 0,
    tempIndex = 0,
    tempDir = null,
    images = {},
    queued = {},
    cwd = process.cwd(),
    key = null,
    fn = null,
    setup = {
        "api-root": "api",
        "temp-dir": "tmp",
        "key": null,
        "port": 8181,
        "https-port": null,
        "ssl-cert": null,
        "ssl-key": null,
        "config" : null,
        "targets" : { },
        "filters" : {
            "gpx" : {
                "path": "gpx",
                "args": [ "{file-in}", "{file-out}" ],
                "filename": "print-{seq}.x3g"
            },
            "gx": {
                "ext": ".gx",
                "path": "bin/gx-print",
                "args": [ "{host}", "{port}", "{file-in}", "{file-out}", "{time}", "{length}", "{filename}" ]
            }
        }
    };

/** handle command-line arguments */
process.argv.slice(2).forEach(v => {
    if (key) {
        if (fn) v = fn(v);
        setup[key] = v;
        key = null;
        fn = null;
    } else {
        if (v.startsWith("-")) v = v.substring(1);
        if (v.startsWith("-")) v = v.substring(1);
        switch (v) {
            case 'port':
            case 'https-port':
                key = v;
                fn = parseInt;
                break;
            case 'ssl-cert':
            case 'ssl-key':
                key = v;
                break;
            case 'config':
                key = v;
                break;
            case 'target':
                key = v;
                fn = addTarget;
                break;
            default:
                throw "invalid option: "+v;
        }
    }
});

if (setup['config']) setup = Object.assign(setup, decode(fs.readFileSync(setup['config'])));
if (setup['ssl-key']) setup['ssl-key'] = fs.readFileSync(setup['ssl-key']);
if (setup['ssl-cert']) setup['ssl-cert'] = fs.readFileSync(setup['ssl-cert']);

/** temp dir for filtering */
tempDir = cwd + "/" + (setup["temp-dir"] || "tmp");
mkdirs([tempDir]);

var apiroot = ["/",setup["api-root"] || 'api',"/"].join(''),
    handler = connect()
        .use(init)
        .use(api)
        .use(serve(cwd + "/static/"))
    ;

if (setup['port']) {
    http.createServer(handler).listen(setup.port);
    log("grid-print started http server on port "+setup['port']);
}

if (setup['https-port']) {
    https.createServer({
        key: setup['ssl-key'],
        cert: setup['ssl-cert']
    }, handler).listen(setup['https-port']);
    log("grid-print started https server on port "+setup['https-port']);
}
