#!/usr/bin/env node

function log(o) {
    if (typeof(o) === 'object') {
        console.log(JSON.stringify(o));
    } else {
        console.log(o);
    }
}

function lastmod(path) {
    try {
        return fs.statSync(path).mtime.getTime();
    } catch (e) {
        return 0;
    }
}

function mkdirs(path) {
    var root = "";
    path.forEach(seg => {
        if (root) {
            root = root + "/" + seg;
        } else {
            root = seg;
        }
        lastmod(root) || fs.mkdirSync(root);
    });
}

function encode(obj) {
    return JSON.stringify(obj);
}

function decode(str) {
    return JSON.parse(str);
}

function setCORSHeaders(req,res) {
    res.setHeader("Access-Control-Allow-Origin", req.headers['origin'] || '*');
    res.setHeader("Access-Control-Allow-Credentials", true);
    res.setHeader("Access-Control-Allow-Headers", "X-Moto-Ajax");
}

function init(req, res, next) {
    var parsed = url.parse(req.url, true);
    req.gs = {
        path: parsed.pathname,
        query: parsed.query,
    };
    if (req.method === 'OPTIONS') {
        setCORSHeaders(req,res);
        res.setHeader("Allow", "GET,POST,OPTIONS");
        res.end();
    } else {
        next();
    }
}

function api(req, res, next) {
    if (!req.gs.path.startsWith(apiroot)) return next();

    var queueEntry;

    switch (req.gs.path.substring(apiroot.length)) {

        case "targets":
            setCORSHeaders(req,res);
            res.end(encode(setup.targets));
            break;

        case "check":
            queueEntry = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            res.end(encode(
                queueEntry ? {
                    key: queueEntry.key,
                    status: queueEntry.status,
                    error: queueEntry.error,
                    done: queueEntry.done
                } : {
                    error: "invalid key"
                }
            ));
            break;

        case "wait":
            queueEntry = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            if (queueEntry) {
                log({wait_on:queueEntry.key});
                queueEntry.waiting.push(res);
            } else {
                res.end(encode({error:"invalid queue key"}));
            }
            break;

        case "print":
            let query = req.gs.query;

            if (req.method !== 'POST') return next();
            if (!query.filename) return next();
            if (!query.target) return next();

            var body = '';
            var queueKey = new Date().getTime().toString(36);

            queued[queueKey] = queueEntry = {
                key:    queueKey,           // unique uid for queue entry
                data:   null,               // gcode
                done:   false,              // queue item completed
                error:  false,              // an error occurred
                status: "queueing",
                target: query.target,
                name:   query.filename || "gprint",
                estime: query.time || 0,    // estimated print time
                fused:  query.length || 0,  // filament used
                waiting: [],                // http clients waiting
                cleanup: []                 // tmp file names to cleanup
            };

            req.on('data', data => {
                body += data
            });

            req.on('end', () => {
                try {
                    body = body.split("\0");
                    var image = body[1] || null;
                    var gcode = body[0];
                    queueEntry.data = gcode;
                    queueEntry.status = "queued";
                    log({key:queueKey, size:body.length, file:queueEntry.filename, target:req.gs.query.target});
                    setCORSHeaders(req,res);
                    res.end(encode({key:queueKey}));

                    if (image) {
                        png2bmp(Buffer.from(image, "base64"), bmp => {
                            queueEntry.image = bmp;
                            queueTarget(queueEntry);
                        });
                    } else {
                        queueTarget(queueEntry);
                    }
                } catch (e) {
                    console.log(e);
                    log(e);
                    res.writeHead(500);
                    res.end(encode({error:e.toString()}));
                }
            });

            break;

        default:
            next();
    }

}

function tempFileName() {
    return tempDir + "/" + (new Date().getTime().toString(36)) + "-" + (tempIndex++) + ".tmp";
}

function formPost(host, port, data, name, queueEntry, onDone) {
    log({post:queueEntry.key, host:host, port:port});
    queueEntry.status = "posting";
    var form = new FormData(), req;
    form.append("file", data, name);
    form.append("submit", "submit");
    var track = progress();
    req = form.submit("http://"+host+":"+port+"/upload.cgi", function(err, res) {
        if (res) res.resume();
        if (err) {
            log({key:queueEntry.key, err:err});
            queueEntry.error = true;
            queueEntry.status = err.toString();
        } else {
            log(encode({key:queueEntry.key, done:true}));
            queueEntry.status = "complete";
        }
        onDone();
    }, track);
    track.on('progress', function(progress) {
        queueEntry.progress = progress.percentage;
    });
}

function finish(queueEntry) {
    if (!queueEntry.error) {
        queueEntry.status = "finished";
    }
    queueEntry.data = null;
    queueEntry.done = true;
    queueEntry.waiting.forEach(function(res) {
        res.end(encode({
            key: queueEntry.key,
            status: queueEntry.status,
            error: queueEntry.error,
            done: queueEntry.done
        }));
    });
    // expire completed entries and tmp files after 10 minutes
    setTimeout(function() {
        delete queued[queueEntry.key];
        queueEntry.cleanup.forEach(filename => {
            try { fs.unlinkSync(filename) } catch (e) { log(e) }
        });
    }, 600000);
}

function processFilters(queueEntry, index) {
    const filter = Object.assign({}, queueEntry.filters[index]);
    const target = queueEntry.target;

    if (filter.formPost || filter.post) {
        var data = queueEntry.data;
        var name = queueEntry.name;
        formPost(filter.host, filter.port || 80, data, name, queueEntry, () => {
            processFilters(queueEntry, index + 1);
        });
        return;
    }

    if (filter.exec) {
        var img = '';
        var ext = filter.ext || '.gcode';
        var fname = filter.name || queueEntry.name;
        var file = tempFileName();

        // emit file with data and add to cleanup list
        fs.writeFileSync(file, queueEntry.data);
        queueEntry.cleanup.push(file);

        // storge image, if present, and add to cleanup list
        if (queueEntry.image) {
            img = tempFileName();
            fs.writeFileSync(img, queueEntry.image.data);
            queueEntry.cleanup.push(img);
        }

        // add missing file name extension
        if (fname.indexOf(ext) < 0) {
            fname = fname + ext;
         }

        fname = fname.replace("{seq}", printSequence++);
        fname = fname.replace("{name}", queueEntry.name);

        args = (filter.args || []).slice();
        args.forEach((val,idx) => {
            // replace any provided key/values from target
            for (var tkey in target) {
                val = val.replace("{" + tkey + "}", target[tkey]);
            }
            val = val.replace("{file}", file);
            val = val.replace("{print-time}", queueEntry.estime);
            val = val.replace("{filament-used}", queueEntry.fused);
            val = val.replace("{name}", fname);
            val = val.replace("{image}", img);
            args[idx] = val;
        });

        queueEntry.status = "exec " + filter.exec;

        proc = spawn(filter.exec, args)
            .on('error', error => {
                log(error);
                queueEntry.error = true;
                queueEntry.status = error.toString();
                finish(queueEntry);
            })
            .on('exit', () => {
                // refresh contents of data (for formPost)
                if (filter.refresh) {
                    queueEntry.data = fs.readFileSync(file);
                }
                processFilters(queueEntry, index + 1);
            });

        proc.stdout.on('data', data => log({
            out: data.toString()
        }));

        proc.stderr.on('data', err => log({
            err: err.toString()
        }));

        return;
    }

    finish(queueEntry);
}

function queueTarget(queueEntry) {
    var target = setup.targets[queueEntry.target],
        filter = setup.filters[target.filter],
        proc, args;

    if (!target) throw "invalid target: " + queueEntry.target;
    if (!filter) throw "missing filter for " + queueEntry.target;

    queueEntry.target = target;

    if (Array.isArray(filter)) {
        queueEntry.filters = filter;
        processFilters(queueEntry, 0);
    } else {
        queueEntry.filters = [ filter ];
        processFilters(queueEntry, 0);
    }
}

/* *********************************************
 * Start it up
 ********************************************* */

var fs = require('fs'),
    url = require('url'),
    http = require('http'),
    https = require('https')
    serve = require('serve-static')
    connect = require('connect'),
    spawn = require('child_process').spawn,
    progress = require('progress-stream'),
    FormData = require('form-data'),
    png2bmp = require('./gx-util').png2bmp,
    printSequence = 0,
    tempIndex = 0,
    tempDir = null,
    queued = {},
    cwd = process.cwd(),
    key = null,
    fn = null,
    setup = {
        "api-root": "api",
        "temp-dir": "tmp",
        "key": null,
        "port": 8181,
        "https-port": null,
        "ssl-cert": null,
        "ssl-key": null,
        "config" : null,
        "targets" : { },
        "filters" : {
            "post": {
                "post": true
            },
            "x3g" : [{
                "exec": "gpx",
                "args": [ "{file}", "{file}.x3g" ],
            }, {
                "exec": "mv",
                "args": [ "{file}.x3g", "{file}" ],
                "refresh": true
            }],
            "gx": {
                "exec": "bin/gx-print",
                "args": [ "{host}", "{port}", "{file}", "{print-time}", "{filament-used}", "{name}", "{image}" ],
                "ext": ".gx"
            }
        }
    };

/** handle command-line arguments */
process.argv.slice(2).forEach(v => {
    if (key) {
        if (fn) v = fn(v);
        setup[key] = v;
        key = null;
        fn = null;
    } else {
        if (v.startsWith("-")) v = v.substring(1);
        if (v.startsWith("-")) v = v.substring(1);
        switch (v) {
            case 'port':
            case 'https-port':
                key = v;
                fn = parseInt;
                break;
            case 'ssl-cert':
            case 'ssl-key':
                key = v;
                break;
            case 'config':
                key = v;
                break;
            default:
                throw "invalid option: "+v;
        }
    }
});

if (setup['config']) setup = Object.assign(setup, decode(fs.readFileSync(setup['config'])));
if (setup['ssl-key']) setup['ssl-key'] = fs.readFileSync(setup['ssl-key']);
if (setup['ssl-cert']) setup['ssl-cert'] = fs.readFileSync(setup['ssl-cert']);

/** temp dir for filtering */
tempDir = cwd + "/" + (setup["temp-dir"] || "tmp");
mkdirs([tempDir]);

var apiroot = ["/",setup["api-root"] || 'api',"/"].join(''),
    handler = connect()
        .use(init)
        .use(api)
        .use(serve(cwd + "/static/"))
    ;

if (setup['port']) {
    http.createServer(handler).listen(setup.port);
    log("grid-print started http server on port "+setup['port']);
}

if (setup['https-port']) {
    https.createServer({
        key: setup['ssl-key'],
        cert: setup['ssl-cert']
    }, handler).listen(setup['https-port']);
    log("grid-print started https server on port "+setup['https-port']);
}
