#!/usr/bin/env node

function log(o) {
    if (typeof(o) === 'object') {
        console.log(JSON.stringify(o));
    } else {
        console.log(o);
    }
}

function lastmod(path) {
    try {
        return fs.statSync(path).mtime.getTime();
    } catch (e) {
        return 0;
    }
}

function mkdirs(path) {
    var root = "";
    path.forEach(seg => {
        if (root) {
            root = root + "/" + seg;
        } else {
            root = seg;
        }
        lastmod(root) || fs.mkdirSync(root);
    });
}

function encode(obj) {
    return JSON.stringify(obj);
}

function decode(str) {
    return JSON.parse(str);
}

function setCORSHeaders(req,res) {
    res.setHeader("Access-Control-Allow-Origin", req.headers['origin'] || '*');
    res.setHeader("Access-Control-Allow-Credentials", true);
    res.setHeader("Access-Control-Allow-Headers", "X-Moto-Ajax");
}

function init(req, res, next) {
    var parsed = url.parse(req.url, true);
    req.gs = {
        path: parsed.pathname,
        query: parsed.query,
    };
    if (req.method === 'OPTIONS') {
        setCORSHeaders(req,res);
        res.setHeader("Allow", "GET,POST,OPTIONS");
        res.end();
    } else {
        next();
    }
}

function api(req, res, next) {
    if (!req.gs.path.startsWith(apiroot)) return next();

    var queueData;

    switch (req.gs.path.substring(apiroot.length)) {
        case "targets":
            setCORSHeaders(req,res);
            res.end(encode(setup.targets));
            break;
        case "check":
            queueData = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            res.end(encode(
                queueData ? {
                    key: queueData.key,
                    pct: queueData.progress,
                    status: queueData.status,
                    error: queueData.error || false,
                    done: queueData.done
                } : {
                    error: "invalid key"
                }
            ));
            break;
        case "wait":
            queueData = queued[req.gs.query.key];
            setCORSHeaders(req,res);
            if (queueData) {
                log({add_wait:queueData.key});
                queueData.waiting.push(res);
            } else {
                res.end(encode({error:"invalid key"}));
            }
            break;
        case "print":
            let query = req.gs.query;

            if (req.method !== 'POST') return next();
            if (!query.filename) return next();
            if (!query.target) return next();

            var body = '',
                queueKey = new Date().getTime().toString(36);

            req.on('data', data => { body += data });
            req.on('end', () => {
                try {
                    body = body.split("\0");
                    var image = body[1] || null;
                    var gcode = body[0];
                    queued[queueKey] = queueData = {
                        key: queueKey,
                        data: gcode,
                        error: false,
                        status: "queueing",
                        target: query.target,
                        filename: query.filename || "gprint",
                        ptime: query.time || 0,
                        plength: query.length || 0,
                        waiting: []
                    };
                    log({key:queueKey, size:body.length, file:queueData.filename, target:req.gs.query.target});
                    setCORSHeaders(req,res);
                    res.end(encode({key:queueKey}));
                    if (image) {
                        image = Buffer.from(image, "base64");
                        var png = new PNG().parse(image, (err, data) => {
                            var th = 80;
                            var tw = 60;
                            var ratio = png.width / png.height;
                            if (ratio > 4/3) {
                                var div = png.height / tw;
                                var xoff = Math.round((png.width - (th * div)) / 2);
                                var yoff = 0;
                            } else {
                                var div = png.width / th;
                                var xoff = 0;
                                var yoff = Math.round((png.height - (tw * div)) / 2);
                            }
                            var buf = new Buffer(th * tw * 4);
                            for (var y=0; y<tw; y++) {
                                var dy = Math.round(y * div + yoff);
                                if (dy < 0 || dy > png.height) continue;
                                var ey = Math.round((y+1) * div + yoff);
                                for (var x=0; x<th; x++) {
                                    var dx = Math.round(x * div + xoff);
                                    if (dx < 0 || dx > png.width) continue;
                                    var ex = Math.round((x+1) * div + xoff);
                                    var bidx = (y * th + x) * 4;
                                    var pixval = png.averageBlock(dx,dy,ex,ey);
                                    buf[bidx+0] = pixval[0];
                                    buf[bidx+1] = pixval[1];
                                    buf[bidx+2] = pixval[2];
                                    buf[bidx+3] = pixval[3];
                                }
                            }
                            // BMP.encode({data:png.data, width:png.width, height:png.height});
                            queueData.image = BMP.encode({data:buf, width:th, height:tw});
                            printTarget(queueData);
                        });
                    } else {
                        printTarget(queueData);
                    }
                } catch (e) {
                    console.log(e);
                    log(e);
                    res.writeHead(500);
                    res.end(encode({error:e.toString()}));
                }
            });

            break;
        default:
            next();
    }

}

function addTarget(host, name, filter) {
    setup.targets[name || host] = {
        host: host,
        filter: filter
    };
}

function tempFileName() {
    return tempDir + "/" + (new Date().getTime().toString(36)) + "-" + (tempIndex++) + ".tmp";
}

function postFile(host, queueData) {
    log({key:queueData.key, postTo:host});
    queueData.status = "posting";
    var form = new FormData(), req;
    form.append("file", queueData.data, queueData.filename);
    form.append("submit", "submit");
    var track = progress();
    req = form.submit("http://"+host+"/upload.cgi", function(err, res) {
        if (res) res.resume();
        if (err) {
            log({key:queueData.key, err:err});
            queueData.error = true;
            queueData.status = err.toString();
        } else {
            log(encode({key:queueData.key, done:true}));
            queueData.status = "complete";
        }
        queueData.data = null;
        queueData.done = true;
        setTimeout(function() {
            delete queued[queueData.key];
        }, 600000);
        finish(queueData);
    }, track);
    track.on('progress', function(progress) {
        queueData.progress = progress.percentage;
        // log(progress);
    });
}

function finish(queueData) {
    queueData.waiting.forEach(function(res) {
        res.end(encode({
            key: queueData.key,
            done: queueData.done,
            error: queueData.error,
            status: queueData.status
        }));
    });
}

function printTarget(queueData) {
    var pt = setup.targets[queueData.target],
        filter, proc, args;

    if (!pt) throw "invalid target: "+queueData.target;
    if (pt.filter && (filter = setup.filters[pt.filter])) {
        var ext = filter.ext || '.gcode';
        var img = '';
        var fin = tempFileName();
        var fout = tempFileName();
        var fname = filter.filename || queueData.filename;
        if (queueData.image) {
            img = tempFileName();
            fs.writeFileSync(img, queueData.image.data);
        }
        if (fname.indexOf(ext) < 0) { fname = fname + ext }
        fname = fname.replace("{seq}", printSequence++);
        fname = fname.replace("{name}", queueData.filename);
        fs.writeFileSync(fin, queueData.data);
        args = filter.args.slice();
        args.forEach((val,idx) => {
            val = val.replace("{host}", pt.host);
            val = val.replace("{port}", pt.port);
            val = val.replace("{file-in}", fin);
            val = val.replace("{file-out}", fout);
            val = val.replace("{time}", queueData.ptime);
            val = val.replace("{length}", queueData.plength);
            val = val.replace("{filename}", fname);
            val = val.replace("{image}", img);
            args[idx] = val;
        });
        proc = spawn(filter.path, args);
        proc.on('error', error => {
            log(error);
            queueData.done = true;
            queueData.error = true;
            queueData.status = error.toString();
            finish(queueData);
        });
        proc.on('exit', () => {
            if (!lastmod(fout)) {
                log("missing filtered output for "+filename);
                queueData.done = true;
                queueData.error = true;
                queueData.status = "missing filter output";
                return;
            }
            try {
                queueData.filename = fname;
                queueData.data = fs.readFileSync(fout);
                if (filter.post) {
                    postFile(pt.host, queueData);
                } else {
                    queueData.done = true;
                    queueData.error = false;
                    queueData.status = "spooled";
                    finish(queueData);
                }
            } catch (e) {
                queueData.done = true;
                queueData.error = true;
                queueData.status = e.toString();
            }
            fs.unlinkSync(fin);
            fs.unlinkSync(fout);
            if (img) fs.unlinkSync(img);
        });
        proc.stdout.on('data', data => log({
            out: data.toString()
        }));
        proc.stderr.on('data', err => log({
            err: err.toString()
        }));
    } else {
        postFile(pt.host, queueData);
    }
}

/* *********************************************
 * Start it up
 ********************************************* */

var fs = require('fs'),
    url = require('url'),
    http = require('http'),
    https = require('https')
    serve = require('serve-static')
    connect = require('connect'),
    spawn = require('child_process').spawn,
    progress = require('progress-stream'),
    FormData = require('form-data'),
    PNG = require('pngjs').PNG,
    BMP = require('bmp-js'),
    printSequence = 0,
    tempIndex = 0,
    tempDir = null,
    queued = {},
    cwd = process.cwd(),
    key = null,
    fn = null,
    setup = {
        "api-root": "api",
        "temp-dir": "tmp",
        "key": null,
        "port": 8181,
        "https-port": null,
        "ssl-cert": null,
        "ssl-key": null,
        "config" : null,
        "targets" : { },
        "filters" : {
            "gpx" : {
                "path": "gpx",
                "args": [ "{file-in}", "{file-out}" ],
                "filename": "print-{seq}.x3g"
            },
            "gx": {
                "ext": ".gx",
                "path": "bin/gx-print",
                "args": [ "{host}", "{port}", "{file-in}", "{file-out}", "{time}", "{length}", "{filename}", "{image}" ]
            }
        }
    };

PNG.prototype.pixAt = function(x,y) {
    var idx = (x + this.width * y) * 4;
    var dat = this.data;
    return [
        dat[idx++],
        dat[idx++],
        dat[idx++],
        dat[idx++]
    ];
};

PNG.prototype.averageBlock = function(x1,y1,x2,y2) {
    var val = [0, 0, 0, 0];
    var count = 0;
    for (var x=x1; x<x2; x++) {
        for (var y=y1; y<y2; y++) {
            var v2 = this.pixAt(x,y);
            for (var z=0; z<4; z++) {
                val[z] += v2[z];
            }
            count++;
        }
    }
    for (var z=0; z<4; z++) {
        val[z] = Math.abs(val[z] / count);
    }
    return val;
};

/** handle command-line arguments */
process.argv.slice(2).forEach(v => {
    if (key) {
        if (fn) v = fn(v);
        setup[key] = v;
        key = null;
        fn = null;
    } else {
        if (v.startsWith("-")) v = v.substring(1);
        if (v.startsWith("-")) v = v.substring(1);
        switch (v) {
            case 'port':
            case 'https-port':
                key = v;
                fn = parseInt;
                break;
            case 'ssl-cert':
            case 'ssl-key':
                key = v;
                break;
            case 'config':
                key = v;
                break;
            case 'target':
                key = v;
                fn = addTarget;
                break;
            default:
                throw "invalid option: "+v;
        }
    }
});

if (setup['config']) setup = Object.assign(setup, decode(fs.readFileSync(setup['config'])));
if (setup['ssl-key']) setup['ssl-key'] = fs.readFileSync(setup['ssl-key']);
if (setup['ssl-cert']) setup['ssl-cert'] = fs.readFileSync(setup['ssl-cert']);

/** temp dir for filtering */
tempDir = cwd + "/" + (setup["temp-dir"] || "tmp");
mkdirs([tempDir]);

var apiroot = ["/",setup["api-root"] || 'api',"/"].join(''),
    handler = connect()
        .use(init)
        .use(api)
        .use(serve(cwd + "/static/"))
    ;

if (setup['port']) {
    http.createServer(handler).listen(setup.port);
    log("grid-print started http server on port "+setup['port']);
}

if (setup['https-port']) {
    https.createServer({
        key: setup['ssl-key'],
        cert: setup['ssl-cert']
    }, handler).listen(setup['https-port']);
    log("grid-print started https server on port "+setup['https-port']);
}
