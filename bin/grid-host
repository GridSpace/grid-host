#!/usr/bin/env node

/** Copyright 2014-2018 Stewart Allen <so@a3z.co> -- All Rights Reserved */

const MaxHistory = 100;

/** Common Utilities */

const Util = {
    log: (o) => {
        if (typeof(o) === 'object') {
            console.log(JSON.stringify(o));
        } else {
            console.log(o);
        }
    },

    lastmod: (path) => {
        try {
            return fs.statSync(path).mtime.getTime();
        } catch (e) {
            return 0;
        }
    },

    mkdirs: (path) => {
        let root = "";
        path.forEach(seg => {
            if (root) {
                root = root + "/" + seg;
            } else {
                root = seg;
            }
            Util.lastmod(root) || fs.mkdirSync(root);
        });
    },

    encode: (obj,indent) => {
        return JSON.stringify(obj,undefined,indent);
    },

    decode: (str) => {
        return JSON.parse(str);
    }
};

/** Driver Utilities */

const Driver = {
    cache: {},

    get: (name) => {
        if (Driver.cache[name]) {
            return Driver.cache[name];
        }
        try {
            let driver = require(`../lib/driver-${name}.js`);
            if (driver && driver.name === name && driver.init) {
                Driver.cache[name] = driver;
                driver.init({ Queue, Util, filters: setup.filters });
                return driver;
            }
            console.log({invalid_driver: name});
            return null;
        } catch (error) {
            console.log({missing_driver: name, error});
            return null;
        }
    }
};

/** Active Devices */

const Devices = {
    map: {},

    get: (name) => {
        return Devices.map[name];
    },

    encode: () => {
        const out = {};
        const map = Devices.map;
        for (let key in map) {
            let el = Object.assign({}, map[key]);
            delete el.driver;
            out[key] = el;
        }
        return Util.encode(out,4);
    }
};

/** Print Queue Utilities */

const Queue = {

    keyed: {},

    ordered: [],

    encode: () => {
        const eq = [];
        Queue.ordered.forEach(el => {
            el = Object.assign({}, el);
            delete el.promises;
            delete el.waiting;
            delete el.data;
            delete el.image;
            eq.push(el);
        });
        return Util.encode(eq,4);
    },

    load: (queue) => {
        Queue.keyed = {};
        Queue.ordered = queue;
        queue.forEach(entry => {
            Queue.keyed[entry.key] = entry;
            // legacy import
            if (entry.cleanup) entry.files = entry.cleanup;
        });
    },

    save: () => {
        const queue = Queue.ordered;
        while (queue.length > MaxHistory) {
            Queue.cleanup(queue.shift());
        }
        fs.writeFileSync(setup.queue, Queue.encode());
    },

    add: (key, entry) => {
        Util.log({queue_add: entry.key, entry});
        Queue.keyed[key] = entry;
        Queue.ordered.push(entry);
        Queue.save();
    },

    get: (key) => {
        return Queue.keyed[key];
    },

    cleanup: (entry) => {
        Util.log({queue_del: entry.key});
        // remove temp files
        entry.files.forEach(filename => {
            try { fs.unlinkSync(filename) } catch (e) { log(e) }
        });
    },

    delete: (time) => {
        const queue = Queue.ordered;
        let qclone = queue.slice();
        for (let i=0; qclone && i<qclone.length; i++) {
            let entry = qclone[i];
            if (entry.time.add === time) {
                Queue.cleanup(entry);
                // remove entry from queue
                queue.splice(i,1);
                // terminate for loop
                qclone = null;
                // update persisted queue
                Queue.save();
            }
        }
        return qclone === null;
    }
};

/** Web Request Helpers */

const Web = {

    serve: require('serve-static'),

    allowCORS: (req,res) => {
        res.setHeader("Access-Control-Allow-Origin", req.headers['origin'] || '*');
        res.setHeader("Access-Control-Allow-Credentials", true);
        res.setHeader("Access-Control-Allow-Headers", "X-Moto-Ajax");
    },

    init: (req, res, next) => {
        let parsed = url.parse(req.url, true);
        req.gs = {
            path: parsed.pathname,
            query: parsed.query,
        };
        if (req.method === 'OPTIONS') {
            Web.allowCORS(req,res);
            res.setHeader("Allow", "GET,POST,OPTIONS");
            res.end();
        } else {
            next();
        }
    },

    api: (req, res, next) => {
        let path = req.gs.path,
            query = req.gs.query,
            remoteIP = req.connection.remoteAddress,
            queueEntry,
            device;

        // pass unless url starts with /api/
        if (!path.startsWith(apiroot)) return next();

        // require key when set in config
        if (setup.key && query.key !== setup.key) {
            res.writeHead(401);
            res.end();
            return;
        }

        Web.allowCORS(req,res);

        switch (path.substring(apiroot.length)) {

            // return list of print Devices
            case "targets":
                res.end(Devices.encode());
                break;

            // return list of last MaxHistory prints
            case "queue":
                res.end(Queue.encode());
                break;

            // delete entry queued at given time
            case "queue.del":
                Queue.delete(parseInt(query.time));
                res.end(Queue.encode());
                break;

            // return status of queued print from unique key
            case "check":
                queueEntry = Queue.get(query.key);
                res.end(Util.encode(
                    queueEntry ? {
                        key: queueEntry.key,
                        status: queueEntry.status,
                        error: queueEntry.error,
                        done: queueEntry.done
                    } : {
                        error: "invalid key"
                    }
                ));
                break;

            // call blocks until queue task completes (when it's running)
            case "wait":
                queueEntry = Queue.get(query.key);
                if (queueEntry) {
                    Util.log({wait_on: queueEntry.key});
                    queueEntry.waiting.push(res);
                } else {
                    res.end(Util.encode({error:"invalid queue key"}));
                }
                break;

            // queue new print job and assign a unique queue key
            case "print":
                if (req.method !== 'POST') return next();
                if (!query.filename) return next();
                if (!query.target) return next();

                device = Devices.get[query.target];
                if (!device) {
                    res.writeHead(404);
                    res.end(Util.encode({error:"invalid device", device: query.target}));
                    return;
                }

                let driver = device.driver;
                if (!driver) {
                    res.writeHead(404);
                    res.end(Util.encode({error:"misconfigured device", device: query.target}));
                    return;
                }

                let body = '';
                let queueKey = new Date().getTime().toString(36);
                let filename = query.filename || "gprint";
                let estime = parseInt(query.time || 0);
                let fused = parseInt(query.length || 0);

                queueEntry = {
                    time: {                     // timestamps
                        add: Date.now(),        // queue entry creation
                        queued: null,           // file fully received
                        spooled: null           // file sent to target
                    },
                    key:    queueKey,           // unique uid for queue entry
                    from:   remoteIP,           // client that submitted job
                    data:   null,               // raw gcode or file
                    done:   false,              // queue item completed
                    error:  false,              // an error occurred
                    status: "queueing",         // human readable status
                    target: query.target,       // named device target
                    device: device,             // device record
                    name:   filename,           // filename as seen by device
                    estime: estime,             // estimated print time
                    fused:  fused,              // filament used
                    waiting: [],                // http clients waiting
                    files: []                   // tmp file names to cleanup
                };

                // create queue entry and save
                Queue.add(queueKey, queueEntry);

                // accumulate post data
                req.on('data', data => {
                    body += data
                });

                // file receive completed
                req.on('end', () => {
                    try {
                        // if gcode is null terminated, extract the following
                        // image buffer in base64 encoded png format
                        body = body.split("\0");
                        let gcode = body[0];
                        let image = body[1] || null;

                        queueEntry.size = gcode.length;
                        queueEntry.data = gcode;
                        queueEntry.status = "queued";
                        queueEntry.time.queued = Date.now();

                        Queue.save();

                        res.end(Util.encode({key:queueKey}));

                        Util.log({
                            key: queueKey,
                            size: body.length,
                            file: queueEntry.filename,
                            target: query.target
                        });

                        let promse;
                        if (image) {
                            promise = png2bmp(Buffer.from(image, "base64"))
                                .then(bmp => {
                                    queueEntry.image = bmp;
                                    return driver.send(device, queueEntry);
                                });
                        } else {
                            promise = driver.send(device, queueEntry);
                        }
                        promise
                            .then(sent => {
                                console.log({sent});
                            })
                            .catch(error => {
                                console.log({send_error: error});
                            });
                    } catch (e) {
                        console.log(e);
                        Util.log(e);
                        res.writeHead(500);
                        res.end(Util.encode({error:e.toString()}));
                    }
                });

                break;

            case "print.cancel":
                device = Devices.get(query.target);
                if (!device) {
                    res.end(Util.encode({cancel: false, error: "invalid device"}));
                } else {
                    if (device.driver.cancel) {
                        device.driver
                            .cancel(device)
                            .then(ok => {
                                res.end(Util.encode({cancel: true}));
                            })
                            .catch(error => {
                                res.end(Util.encode({cancel: false, error}));
                            })
                    } else {
                        res.end(Util.encode({cancel: false, error: "device no cancel"}));
                    }
                }
                break;

            default:
                next();
        }
    }
};

/** update active device status */
function updateActive() {
    for (let name in Devices.map) {
        let active = Devices.map[name];
        let driver = active.driver;
        if (driver.status) {
            driver
                .status(active)
                .then(status => {
                    active.status = status;
                    Util.log({name, status});
                })
                .catch(error => {
                    Util.log({name, error});
                });
        }
    }
}

/** turn target setup records in active records */
function resolveDevices() {
    const resolved = {};
    for (let name in setup.targets) {
        let device = setup.targets[name];
        let type = device.driver || "exec";
        let driver = Driver.get(type);
        if (!driver) {
            // Util.log({missing_driver_for: name, type});
            continue;
        }
        let active = Object.assign({}, device);
        active.name = name;
        active.driver = driver;
        resolved[name] = active;
        Util.log({activated: name, type});
    }
    Devices.map = resolved;
    setTimeout(updateActive, 1000);
}

/* *********************************************
 * Start it up
 ********************************************* */

var fs = require('fs'),
    url = require('url'),
    http = require('http'),
    https = require('https')
    connect = require('connect'),
    linebuf = require("buffer.lines"),
    png2bmp = require('../lib/image').png2bmp,
    WebSocket = require('ws'),
    http_server = null,
    https_server = null,
    printSequence = 0,
    tempIndex = 0,
    cwd = process.cwd(),
    key = null,
    fn = null,
    setup = {
        // use command-line to override
        "config" : "etc/config.json",
        // persisted queue state
        "queue" : "etc/queue.json",
        // protect http(s) access with a shared secret key
        "key": null,
        // kiri:moto auto-detect only works with "default" at the moment
        "org": "default",
        // passed to kiri:moto auto-detect as grid:host url. use url format
        "autohost": false,
        // instead of 'autohost' provide the host name passed to grid.space
        "host": null,
        "http-port": 8111,
        "https-port": 8112,
        // provided cert/key bound to local.grid.space so can be
        // added to your local dns or /etc/hosts to point to your
        // grid:host server. allows kiri:moto inside Onshape to
        // access your grid:host server without clunky workarounds.
        "ssl-cert": "etc/ssl-local-cert.pem",
        "ssl-key": "etc/ssl-local-key.pem",
        // your config should provide these
        "Devices" : { },
        // your config filters will be added to this list
        "filters" : {
            "x3g" : {
                "exec": "gpx",
                "args": [ "{file}", "{file}.x3g" ]
            },
            "gx": {
                "exec": "bin/gx-util",
                "args": [ "{host}", "{port}", "{file}", "{print-time}", "{filament-used}", "{name}", "{image}" ],
                "ext": ".gx"
            },
            "n2": {
                "exec": "bin/n2-util",
                "args": [ "{host}", "{file}", "{name}" ],
                "ext": ".gcode"
            },
            "scp": {
                "exec": "scp",
                "args": [ "{file}", "{user}@{host}:{dir}/{name}" ]
            },
            "cp": {
                "exec": "cp",
                "args": [ "{file}", "{dir}/{name}" ]
            }
        }
    };

/** process command-line arguments */
process.argv.slice(2).forEach(v => {
    if (!key) {
        let split = false;
        if (v.startsWith("--")) {
            v = v.substring(2).split("=");
            key = v[0];
            v = v[1];
            split = true;
        } else if (v.startsWith("-")) {
            key = v.substring(1);
        } else {
            throw "invalid format: " + v;
        }
        switch (key) {
            case 'port':
            case 'http-port':
            case 'https-port':
                fn = parseInt;
                break;
            case 'ssl-cert':
            case 'ssl-key':
            case 'config':
            case 'queue':
                break;
            default:
                throw "invalid option: " + key;
        }
        if (!split) return;
    }
    if (key) {
        setup[key] = fn ? fn(v) : v;
        key = null;
        fn = null;
    }
});

/** overlay file-based config onto system defaults */
function mergeConfig(config) {
    for (let key in config) {
        switch (key) {
            case 'Devices':
            case 'filters':
                Object.assign(setup[key], config[key]);
                break;
            default:
                setup[key] = config[key];
                break;
        }
    }
    return setup;
}

if (setup['config']) setup = mergeConfig(Util.decode(fs.readFileSync(setup['config'])));
if (setup['ssl-key']) setup['ssl-key'] = fs.readFileSync(setup['ssl-key']);
if (setup['ssl-cert']) setup['ssl-cert'] = fs.readFileSync(setup['ssl-cert']);

var apiroot = "/api/",
    report = ["grid:host"],
    wport = setup['http-port'] || setup['port'],
    sport = setup['https-port'],
    handler = connect()
        .use(Web.init)
        .use(Web.api)
        .use(Web.serve(cwd + "/web/host/"))
    ;

/** open http port when specified */
if (wport) {
    http_server = http.createServer(handler).listen(wport);
    report.push("http @ " + wport);
}

/** open https port when specified */
if (sport) {
    https_server = https.createServer({
        key: setup['ssl-key'],
        cert: setup['ssl-cert']
    }, handler).listen(sport);
    report.push("https @ " + sport);
}

/** start disconnected web socket server that can be shared */
if (setup['wss']) {
    report.push("websockets");
    const wss = new WebSocket.Server({ noServer: true });
    const upgrade = (request, socket, head) => {
        const pathname = url.parse(request.url).pathname;
        if (pathname === "/ws") {
            wss.handleUpgrade(request, socket, head, (ws) => {
              wss.emit('connection', ws, request);
            });
        } else {
            socket.destroy();
        }
    };
    wss.on('connection', (ws) => {
      ws.on('message', (message) => { });
    });
    if (http_server) http_server.on("upgrade", upgrade);
    if (https_server) https_server.on("upgrade", upgrade);
}

/** reload saved queue state (TODO repair and delete dangling tmp files) */
if (Util.lastmod(setup.queue)) Queue.load(Util.decode(fs.readFileSync(setup.queue)));

/** output date */
report.push(new Date().toString());

/** startup report */
Util.log(report.join(" | "));

/** resolve Devices from config records */
resolveDevices();

/**
 * store org <> host map for auto-grid-host in kiri
 * if host not specified, use ip:port of grid-host server
 */
if (setup.org && (setup.host || setup.autohost)) {
    let host = setup.host || null;
    let nif = require('os').networkInterfaces();

    for (let key in nif) {
        if (host) break;
        let nic = nif[key];
        nic.forEach(ni => {
            if (host) return;
            if (!ni.internal && ni.family === "IPv4") {
                if (setup['https-port']) {
                    host = "https://" + ni.address + ":" + setup['https-port'];
                } else {
                    host = "http://" + ni.address + ":" + setup['port'];
                }
            }
        });
    }

    let args = [
        "org=" + encodeURIComponent(setup.org),
        "host=" + encodeURIComponent(host)
    ].join('&');

    console.log({register: host || "*autohost*", org: setup.org});

    https.get("https://grid.space/api/host_up?" + args, (res) => {
        // console.log({sc: res.statusCode});
        res.on("data", (data) => {
            // console.log({data: data.toString()});
        })
    }).on("error", (error) => {
        // console.log(error);
    });
}
